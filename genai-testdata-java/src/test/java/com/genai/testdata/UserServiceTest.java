package com.genai.testdata;

import com.genai.testdata.genai.GenAIDataGenerator;
import com.genai.testdata.model.User;
import com.genai.testdata.service.UserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.*;

// JUnit 5 test class for UserService, demonstrating GenAI-driven test data.
class UserServiceTest {

    private UserService userService;

    // This method runs before each test to ensure a clean state.
    @BeforeEach
    void setUp() {
        userService = new UserService();
    }

    // --- Test Data Generation Methods using GenAIDataGenerator ---

    // Provides a stream of User objects generated by GenAIDataGenerator for parameterized tests.
    // This allows running the same test logic with different generated data sets.
    static Stream<User> diverseUserData() {
        // Prompt for general diverse users
        List<User> users = GenAIDataGenerator.generateUserData(
                "Generate 10 realistic user profiles with diverse ages and countries for an e-commerce platform.",
                10);
        return users.stream();
    }

    // Provides a stream of user objects with specific characteristics (e.g., minors).
    static Stream<User> minorUserData() {
        // Prompt for users under 18
        List<User> users = GenAIDataGenerator.generateUserData(
                "Generate 5 user profiles who are minors (under 18) for a platform with age restrictions.",
                5);
        // Add an assertion to check if generated data meets the prompt criteria (important validation step)
        users.forEach(user -> assertTrue(user.getAge() < 18, "Generated user age was not under 18: " + user.getAge()));
        return users.stream();
    }

    // Provides a stream of user objects for edge cases (e.g., senior citizens).
    static Stream<User> seniorUserData() {
        // Prompt for senior users
        List<User> users = GenAIDataGenerator.generateUserData(
                "Generate 3 user profiles who are senior citizens (over 65).",
                3);
        // Add an assertion to check if generated data meets the prompt criteria
        users.forEach(user -> assertTrue(user.getAge() > 65, "Generated user age was not over 65: " + user.getAge()));
        return users.stream();
    }

    // --- Test Cases Using Generated Data ---

    @ParameterizedTest
    @MethodSource("diverseUserData")
    @DisplayName("Should register diverse users generated by GenAI")
    void shouldRegisterDiverseUsers(User user) {
        // Act
        User registeredUser = userService.registerUser(user);

        // Assert
        assertNotNull(registeredUser, "User should be registered successfully");
        assertEquals(user, registeredUser, "Registered user should match the input user");
        Optional<User> foundUser = userService.findUserById(user.getId());
        assertTrue(foundUser.isPresent(), "User should be found in the database");
        assertEquals(user, foundUser.get(), "Found user should match the registered user");
        System.out.println("Test Passed: Registered user " + user.getFirstName() + " (Age: " + user.getAge() + ", Country: " + user.getCountry() + ")");
    }

    @ParameterizedTest
    @MethodSource("minorUserData")
    @DisplayName("Should handle minor users generated by GenAI (e.g., age restriction check)")
    void shouldHandleMinorUsers(User minorUser) {
        // For demonstration, let's assume our service has an age restriction logic
        // In a real app, this might throw an exception or return an error code.
        System.out.println("Attempting to register minor user: " + minorUser.getFirstName() + " (Age: " + minorUser.getAge() + ")");

        // Simulate a business rule: minors cannot register
        if (minorUser.getAge() < 18) {
            // Expected failure for minors
            IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
                // In a real scenario, registerUser might be modified to throw if age < 18
                // For this simple UserService, we'll just demonstrate handling
                throw new IllegalArgumentException("User under 18 cannot register: " + minorUser.getAge());
            }, "Expected an IllegalArgumentException for minor users.");
            assertTrue(exception.getMessage().contains("under 18"), "Exception message should indicate age restriction.");
        } else {
            // This case should ideally not happen if minorUserData() provides only minors.
            // But it's good for robustness.
            User registeredUser = userService.registerUser(minorUser);
            assertNotNull(registeredUser, "User should be registered if not a minor");
        }
    }

    @ParameterizedTest
    @MethodSource("seniorUserData")
    @DisplayName("Should update senior users generated by GenAI")
    void shouldUpdateSeniorUsers(User seniorUser) {
        // First, register the senior user
        userService.registerUser(seniorUser);
        assertNotNull(userService.findUserById(seniorUser.getId()).orElse(null), "Senior user should be initially registered.");

        // Modify the user's data (e.g., update email and country)
        String originalEmail = seniorUser.getEmail();
        String originalCountry = seniorUser.getCountry();

        seniorUser.setEmail("new." + seniorUser.getFirstName().toLowerCase() + "@updated.com");
        seniorUser.setCountry("Germany"); // Change country

        // Act: Update the user
        User updatedUser = userService.updateUser(seniorUser);

        // Assert
        assertNotNull(updatedUser, "Updated user should not be null");
        assertEquals(seniorUser.getId(), updatedUser.getId(), "User ID should remain the same");
        assertNotEquals(originalEmail, updatedUser.getEmail(), "Email should be updated");
        assertNotEquals(originalCountry, updatedUser.getCountry(), "Country should be updated");
        assertEquals("Germany", updatedUser.getCountry(), "Country should be updated to Germany");

        Optional<User> foundUser = userService.findUserById(seniorUser.getId());
        assertTrue(foundUser.isPresent(), "User should still be found after update");
        assertEquals(updatedUser, foundUser.get(), "Found user should match the updated user");
        System.out.println("Test Passed: Updated senior user " + updatedUser.getFirstName() + " (New Country: " + updatedUser.getCountry() + ")");
    }

    @Test
    @DisplayName("Should retrieve all users generated by a specific prompt")
    void shouldGetAllUsersFromSpecificPrompt() {
        // Generate a specific set of users for this test
        List<User> specificUsers = GenAIDataGenerator.generateUserData(
                "Generate 4 users from European countries.",
                4);

        // Register these users
        specificUsers.forEach(user -> {
            userService.registerUser(user);
            // Additionally validate the generated data quality (e.g., all from EU)
            assertTrue(List.of("USA", "Canada", "UK", "Australia", "Germany", "France", "Japan", "India", "Brazil", "Mexico", "China", "South Africa", "Egypt", "Spain", "Italy").contains(user.getCountry()),
                       "Generated user country should be one of the known countries: " + user.getCountry());
        });


        // Act
        List<User> allUsersInService = userService.getAllUsers();

        // Assert
        assertNotNull(allUsersInService, "List of users should not be null");
        assertEquals(specificUsers.size(), allUsersInService.size(), "All generated users should be in the service");
        assertTrue(allUsersInService.containsAll(specificUsers), "The service should contain all specific generated users");
        System.out.println("Test Passed: Retrieved all " + allUsersInService.size() + " users from a specific prompt.");
    }

    @Test
    @DisplayName("Should not register a user with an existing ID")
    void shouldNotRegisterUserWithExistingId() {
        // Generate a single user
        User user1 = GenAIDataGenerator.generateUserData("Generate one standard user.", 1).get(0);

        // Register the user successfully
        assertNotNull(userService.registerUser(user1));
        assertEquals(1, userService.getAllUsers().size());

        // Attempt to register another user with the same ID (e.g., GenAI accidentally generates a duplicate or we use same prompt twice)
        // Or if GenAI is prompted to make a slight variation but keep same ID for specific test case
        User user2 = new User(user1.getId(), "Duplicate", "User", "duplicate@example.com", 30, "USA");

        // Act
        User duplicateRegisteredUser = userService.registerUser(user2);

        // Assert
        assertNull(duplicateRegisteredUser, "Should not register user with existing ID");
        assertEquals(1, userService.getAllUsers().size(), "User count should remain 1");
        assertEquals(user1, userService.findUserById(user1.getId()).orElse(null), "Original user should remain in the database");
        System.out.println("Test Passed: Prevented registration of duplicate ID " + user1.getId());
    }
}