name: Java Code Review

on:
  pull_request:
    branches:
      - main # Trigger on pull requests targeting the 'main' branch (adjust as needed)

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Needed to checkout code
      pull-requests: write # Needed to post comments on PRs

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for accurate diff generation

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'

      - name: Get PR diff
        id: get_diff
        run: |
          # Get the diff between the base branch (where PR is merged into) and the head of the PR branch.
          # --full-index ensures Git diff includes blob IDs and file modes, which LLM might sometimes use.
          # We redirect the diff output to a temporary file.
          git diff --full-index ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} > pr.diff
          # Check if the diff file is empty (e.g., if no changes or only whitespace changes).
          if [ ! -s pr.diff ]; then
            echo "No substantial diff found. Skipping review."
            echo "::set-output name=diff_exists::false"
          else
            echo "Diff generated and saved to pr.diff."
            echo "::set-output name=diff_exists::true"
          fi
        # Set a step output to conditionally run subsequent steps
        id: diff_generator

      - name: Build Java Reviewer Application
        # Only run this step if a diff was found.
        if: steps.diff_generator.outputs.diff_exists == 'true'
        run: ./gradlew clean build jar

      - name: Run Java Code Reviewer
        id: code_reviewer
        # Only run this step if a diff was found.
        if: steps.diff_generator.outputs.diff_exists == 'true'
        env:
          # Pass the LLM API key as an environment variable.
          # This secret must be configured in your GitHub repository settings.
          LLM_API_KEY: ${{ secrets.LLM_API_KEY }}
        run: |
          # Execute the Java application, passing the path to the diff file.
          # The application will print a JSON array of comments to stdout.
          # We capture this output into a variable named 'comments_json'.
          # Using tr -d '\n' to remove newlines for easier JSON parsing by github-script.
          # However, github-script typically handles multi-line JSON fine if output directly.
          # For robustness, we will try to make sure it's a single line if it causes issues.
          # Update: using `jq -c .` ensures compact JSON on a single line for github-script to capture as string.
          java -jar build/libs/GenAICodeReviewer-Java-0.1.0.jar pr.diff | jq -c . > comments.json
          # Store the JSON content as an output for the next step.
          # We use "cat comments.json | tr -d '\n'" to ensure it's a single line string for action outputs
          # or simply let github-script read it from the file.
          # For this example, let's keep it simple and pass the filename.
          echo "Comments JSON generated and saved to comments.json"
          echo "comments_file=comments.json" >> $GITHUB_OUTPUT

      - name: Post review comments to GitHub PR
        # Only run this step if comments were generated by the Java application.
        # Check if the comments_file output from the previous step exists.
        if: steps.diff_generator.outputs.diff_exists == 'true' && steps.code_reviewer.outputs.comments_file != ''
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const commentsFile = process.env.GITHUB_WORKSPACE + '/' + '${{ steps.code_reviewer.outputs.comments_file }}';
            let comments = [];
            try {
              // Read the JSON file output by the Java application.
              comments = JSON.parse(fs.readFileSync(commentsFile, 'utf8'));
              if (comments.length === 0) {
                console.log('LLM generated no specific comments. Adding a general comment.');
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: "GenAI Code Review: No specific issues or suggestions found by the LLM for this pull request. Looks good!\n\n_This comment was generated automatically by an AI. Please use your own judgment._"
                });
                return; // Exit if no comments were generated.
              }
            } catch (error) {
              console.error('Error parsing comments JSON or reading file:', error);
              // Post an error comment to the PR if the JSON parsing fails.
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `GenAI Code Review encountered an error parsing LLM response. Please check action logs.\nError: ${error.message}\n\n_This comment was generated automatically by an AI. Please use your own judgment._`
              });
              return;
            }

            console.log(`Posting ${comments.length} review comments...`);
            let reviewBody = "## GenAI Code Review Summary\n\n";
            let lineComments = [];

            // Group comments by file for easier review.
            const commentsByPath = comments.reduce((acc, comment) => {
                const path = comment.path;
                if (!acc[path]) {
                    acc[path] = [];
                }
                acc[path].push(comment);
                return acc;
            }, {});

            let fullReviewMarkdown = "## GenAI Code Review\n\n";
            let hasFileComments = false;

            for (const path in commentsByPath) {
                fullReviewMarkdown += `### \`${path}\`\n`;
                commentsByPath[path].forEach(comment => {
                    const startLine = comment.start_line || 0;
                    const endLine = comment.end_line || startLine; // If end_line is 0 or missing, use start_line

                    if (startLine > 0) {
                        // Create a line-specific comment. GitHub API uses `line` for a single line,
                        // `start_line` and `end_line` for a range.
                        // `side` indicates which side of the diff (HEAD for new code).
                        // Note: `position` is relative to the diff hunk, `line` is absolute file line number.
                        // We use `line` here as LLM provides absolute line number.
                        lineComments.push({
                            path: comment.path,
                            line: startLine, // Use 'line' for single-line comments.
                            // If you want range comments, use start_line, end_line, and side.
                            // start_line: startLine,
                            // end_line: endLine,
                            // side: 'HEAD',
                            body: comment.body + "\n\n_This comment was generated automatically by an AI. Please use your own judgment._"
                        });
                        fullReviewMarkdown += `- Line ${startLine}${endLine > startLine ? '-' + endLine : ''}: ${comment.body}\n`;
                    } else {
                        // File-level comment
                        reviewBody += `- **${comment.path}**: ${comment.body}\n`;
                        fullReviewMarkdown += `- File-level: ${comment.body}\n`;
                        hasFileComments = true;
                    }
                });
                fullReviewMarkdown += "\n";
            }

            if (!hasFileComments && comments.length > 0) {
                reviewBody += "No file-level comments. See inline comments for details.\n";
            } else if (comments.length === 0) {
                 reviewBody += "No specific issues or suggestions found by the LLM for this pull request. Looks good!\n";
            }

            reviewBody += "\n_This review was generated automatically by an AI. Please use your own judgment._";

            // Post a general review comment (summary)
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              event: 'COMMENT', // Can be 'APPROVE', 'REQUEST_CHANGES', or 'COMMENT'
              body: reviewBody,
              comments: lineComments // Attach line-specific comments to the review.
            });

            console.log('Review comments posted successfully.');